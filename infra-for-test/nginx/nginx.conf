worker_processes 1;
events {
    worker_connections 1024;
}

http {
    lua_shared_dict lb_counter 1m;
    resolver 127.0.0.11 ipv6=off;
    lua_shared_dict balancer 1m;

    init_by_lua_block {
        local redis = require "resty.redis"
    }

    server {
        listen 9999;

        location /payments {
            content_by_lua_block {
                local cjson = require "cjson.safe"
                local redis = require "resty.redis"

                ngx.req.read_body()
                local body = ngx.req.get_body_data()

                local red = redis:new()
                red:set_timeout(1000)
                local ok, err = red:connect("redis", 6379)
                if not ok then
                    ngx.log(ngx.ERR, "Redis connection error: ", err)
                else
                    local res, err = red:lpush("payments_queue", body)
                    if not res then
                        ngx.log(ngx.ERR, "Redis LPUSH error: ", err)
                    end
                    red:set_keepalive(10000, 100)
                end

                ngx.status = 202
                ngx.say('{"status":"Accepted"}')
                return ngx.exit(202)
            }
        }

        location /payments-summary {
            content_by_lua_block {
                local http = require "resty.http"
                local cjson = require "cjson.safe"

                local args = ngx.req.get_uri_args()
                local from = args["from"]
                local to = args["to"]

                local lb_dict = ngx.shared.lb_counter
                local counter, _ = lb_dict:incr("counter", 1, 0)
                local backends = { "api01", "api02" }
                local target_host = backends[(counter % #backends) + 1]

                local query = {}
                if from then
                    table.insert(query, "from=" .. ngx.escape_uri(from))
                end
                if to then
                    table.insert(query, "to=" .. ngx.escape_uri(to))
                end
                local query_string = (#query > 0) and ("?" .. table.concat(query, "&")) or ""

                local target_url = string.format("http://%s:8080/payments-summary%s", target_host, query_string)

                local httpc = http.new()
                local res, err = httpc:request_uri(target_url, {
                    method = "GET",
                    headers = {
                        ["Accept"] = "application/json"
                    }
                })

                if not res then
                    ngx.status = 502
                    ngx.say(cjson.encode({ error = "Failed to reach backend", detail = err }))
                    return ngx.exit(502)
                end

                ngx.status = res.status
                ngx.header.content_type = res.headers["Content-Type"] or "application/json"
                ngx.say(res.body)
                return ngx.exit(res.status)
            }
        }
    }
}
